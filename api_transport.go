/*
GroupDocs.Translation SDK

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 23.8
*/

package groupdocs_translation_api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
	"reflect"
	"strings"
)

// TransportApiService TransportApi service
type TransportApiService service

type ApiAutoPostRequest struct {
	ctx             context.Context
	ApiService      *TransportApiService
	autoPostRequest *AutoPostRequest
}

func (r ApiAutoPostRequest) AutoPostRequest(autoPostRequest AutoPostRequest) ApiAutoPostRequest {
	r.autoPostRequest = &autoPostRequest
	return r
}

func (r ApiAutoPostRequest) Execute() (*StatusResponse, *http.Response, error) {
	return r.ApiService.AutoPostExecute(r)
}

/*
AutoPost Translate any supported file

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAutoPostRequest
*/
func (a *TransportApiService) AutoPost(ctx context.Context) ApiAutoPostRequest {
	return ApiAutoPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return StatusResponse
func (a *TransportApiService) AutoPostExecute(r ApiAutoPostRequest) (*StatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransportApiService.AutoPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/auto"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.autoPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCsvPostRequest struct {
	ctx            context.Context
	ApiService     *TransportApiService
	csvFileRequest *CsvFileRequest
}

// String in body of request, containing JSON with parameters for translation.
func (r ApiCsvPostRequest) CsvFileRequest(csvFileRequest CsvFileRequest) ApiCsvPostRequest {
	r.csvFileRequest = &csvFileRequest
	return r
}

func (r ApiCsvPostRequest) Execute() (*StatusResponse, *http.Response, error) {
	return r.ApiService.CsvPostExecute(r)
}

/*
CsvPost Translate CSV and TSV files

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCsvPostRequest
*/
func (a *TransportApiService) CsvPost(ctx context.Context) ApiCsvPostRequest {
	return ApiCsvPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return StatusResponse
func (a *TransportApiService) CsvPostExecute(r ApiCsvPostRequest) (*StatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransportApiService.CsvPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/csv"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.csvFileRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDocumentPostRequest struct {
	ctx                     context.Context
	ApiService              *TransportApiService
	textDocumentFileRequest *TextDocumentFileRequest
}

// String in body of request, containing JSON with parameters for translation.
func (r ApiDocumentPostRequest) TextDocumentFileRequest(textDocumentFileRequest TextDocumentFileRequest) ApiDocumentPostRequest {
	r.textDocumentFileRequest = &textDocumentFileRequest
	return r
}

func (r ApiDocumentPostRequest) Execute() (*StatusResponse, *http.Response, error) {
	return r.ApiService.DocumentPostExecute(r)
}

/*
DocumentPost Translate Microsoft Word documents, rtf, txt, odt

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDocumentPostRequest
*/
func (a *TransportApiService) DocumentPost(ctx context.Context) ApiDocumentPostRequest {
	return ApiDocumentPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return StatusResponse
func (a *TransportApiService) DocumentPostExecute(r ApiDocumentPostRequest) (*StatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransportApiService.DocumentPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/document"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.textDocumentFileRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDocumentRequestIdGetRequest struct {
	ctx        context.Context
	ApiService *TransportApiService
	requestId  string
}

func (r ApiDocumentRequestIdGetRequest) Execute() (*CloudFileResponse, *http.Response, error) {
	return r.ApiService.DocumentRequestIdGetExecute(r)
}

/*
DocumentRequestIdGet Return document translation status.  Also return URLs for downloading of translated document if translation was successful

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param requestId GUID which got from /v3/translation/document response
	@return ApiDocumentRequestIdGetRequest
*/
func (a *TransportApiService) DocumentRequestIdGet(ctx context.Context, requestId string) ApiDocumentRequestIdGetRequest {
	return ApiDocumentRequestIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		requestId:  requestId,
	}
}

// Execute executes the request
//
//	@return CloudFileResponse
func (a *TransportApiService) DocumentRequestIdGetExecute(r ApiDocumentRequestIdGetRequest) (*CloudFileResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CloudFileResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransportApiService.DocumentRequestIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/document/{requestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"requestId"+"}", url.PathEscape(parameterValueToString(r.requestId, "requestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHcGetRequest struct {
	ctx        context.Context
	ApiService *TransportApiService
}

func (r ApiHcGetRequest) Execute() (*HealthCheckStatus, *http.Response, error) {
	return r.ApiService.HcGetExecute(r)
}

/*
HcGet Health check for all services.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiHcGetRequest
*/
func (a *TransportApiService) HcGet(ctx context.Context) ApiHcGetRequest {
	return ApiHcGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return HealthCheckStatus
func (a *TransportApiService) HcGetExecute(r ApiHcGetRequest) (*HealthCheckStatus, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *HealthCheckStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransportApiService.HcGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHtmlPostRequest struct {
	ctx              context.Context
	ApiService       *TransportApiService
	sourceLanguage   *string
	targetLanguages  *[]string
	file             *string
	originalFileName *string
	url              *string
	origin           *string
	savingMode       *string
	outputFormat     *string
}

// Language of original file
func (r ApiHtmlPostRequest) SourceLanguage(sourceLanguage string) ApiHtmlPostRequest {
	r.sourceLanguage = &sourceLanguage
	return r
}

// List of target languages
func (r ApiHtmlPostRequest) TargetLanguages(targetLanguages []string) ApiHtmlPostRequest {
	r.targetLanguages = &targetLanguages
	return r
}

// File as byte array
func (r ApiHtmlPostRequest) File(file string) ApiHtmlPostRequest {
	r.file = &file
	return r
}

// Type in the file name. If null will be as request ID.
func (r ApiHtmlPostRequest) OriginalFileName(originalFileName string) ApiHtmlPostRequest {
	r.originalFileName = &originalFileName
	return r
}

// Link to file for translation. Ignore, if \\\&quot;file\\\&quot; property not null
func (r ApiHtmlPostRequest) Url(url string) ApiHtmlPostRequest {
	r.url = &url
	return r
}

// Url or name of application using this SDK. Not required.
func (r ApiHtmlPostRequest) Origin(origin string) ApiHtmlPostRequest {
	r.origin = &origin
	return r
}

// Toggle file saving mode for storage.  Is Files by default.
func (r ApiHtmlPostRequest) SavingMode(savingMode string) ApiHtmlPostRequest {
	r.savingMode = &savingMode
	return r
}

// output file format
func (r ApiHtmlPostRequest) OutputFormat(outputFormat string) ApiHtmlPostRequest {
	r.outputFormat = &outputFormat
	return r
}

func (r ApiHtmlPostRequest) Execute() (*StatusResponse, *http.Response, error) {
	return r.ApiService.HtmlPostExecute(r)
}

/*
HtmlPost Translate HTML files

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiHtmlPostRequest
*/
func (a *TransportApiService) HtmlPost(ctx context.Context) ApiHtmlPostRequest {
	return ApiHtmlPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return StatusResponse
func (a *TransportApiService) HtmlPostExecute(r ApiHtmlPostRequest) (*StatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransportApiService.HtmlPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/html"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.sourceLanguage != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "sourceLanguage", r.sourceLanguage, "")
	}
	if r.targetLanguages != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "targetLanguages", r.targetLanguages, "csv")
	}
	if r.file != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "file", r.file, "")
	}
	if r.originalFileName != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "originalFileName", r.originalFileName, "")
	}
	if r.url != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "url", r.url, "")
	}
	if r.origin != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "origin", r.origin, "")
	}
	if r.savingMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "savingMode", r.savingMode, "")
	}
	if r.outputFormat != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "outputFormat", r.outputFormat, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHugoGetRequest struct {
	ctx        context.Context
	ApiService *TransportApiService
	id         *string
}

// id from PostHugo&gt;
func (r ApiHugoGetRequest) Id(id string) ApiHugoGetRequest {
	r.id = &id
	return r
}

func (r ApiHugoGetRequest) Execute() (*CloudHugoResponse, *http.Response, error) {
	return r.ApiService.HugoGetExecute(r)
}

/*
HugoGet Get hugo syntax structure from markdown file

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiHugoGetRequest
*/
func (a *TransportApiService) HugoGet(ctx context.Context) ApiHugoGetRequest {
	return ApiHugoGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CloudHugoResponse
func (a *TransportApiService) HugoGetExecute(r ApiHugoGetRequest) (*CloudHugoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CloudHugoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransportApiService.HugoGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hugo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHugoPostRequest struct {
	ctx        context.Context
	ApiService *TransportApiService
	file       *os.File
	url        *string
}

// File as byte array
func (r ApiHugoPostRequest) File(file *os.File) ApiHugoPostRequest {
	r.file = file
	return r
}

// Link to file for translation
func (r ApiHugoPostRequest) Url(url string) ApiHugoPostRequest {
	r.url = &url
	return r
}

func (r ApiHugoPostRequest) Execute() (*StatusResponse, *http.Response, error) {
	return r.ApiService.HugoPostExecute(r)
}

/*
HugoPost Run hugo syntax structure analyzing from markdown file

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiHugoPostRequest
*/
func (a *TransportApiService) HugoPost(ctx context.Context) ApiHugoPostRequest {
	return ApiHugoPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return StatusResponse
func (a *TransportApiService) HugoPostExecute(r ApiHugoPostRequest) (*StatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransportApiService.HugoPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hugo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.file == nil {
		return localVarReturnValue, nil, reportError("file is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileLocalVarFormFileName string
	var fileLocalVarFileName string
	var fileLocalVarFileBytes []byte

	fileLocalVarFormFileName = "File"

	fileLocalVarFile := r.file

	if fileLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileLocalVarFile)

		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	}
	if r.url != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "Url", r.url, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiImageToFilePostRequest struct {
	ctx            context.Context
	ApiService     *TransportApiService
	ocrFileRequest *OcrFileRequest
}

// String in body of request, containing JSON with parameters for translation.
func (r ApiImageToFilePostRequest) OcrFileRequest(ocrFileRequest OcrFileRequest) ApiImageToFilePostRequest {
	r.ocrFileRequest = &ocrFileRequest
	return r
}

func (r ApiImageToFilePostRequest) Execute() (*StatusResponse, *http.Response, error) {
	return r.ApiService.ImageToFilePostExecute(r)
}

/*
ImageToFilePost Translate image or scanned pdf and return file

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiImageToFilePostRequest
*/
func (a *TransportApiService) ImageToFilePost(ctx context.Context) ApiImageToFilePostRequest {
	return ApiImageToFilePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return StatusResponse
func (a *TransportApiService) ImageToFilePostExecute(r ApiImageToFilePostRequest) (*StatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransportApiService.ImageToFilePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/image-to-file"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ocrFileRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiImageToTextPostRequest struct {
	ctx           context.Context
	ApiService    *TransportApiService
	source        *string
	targets       *[]string
	format        *string
	url           *string
	rotate        *int32
	isHandwritten *bool
	origin        *string
	route         *string
	file          *os.File
}

// Language of original file
func (r ApiImageToTextPostRequest) Source(source string) ApiImageToTextPostRequest {
	r.source = &source
	return r
}

// List of target languages
func (r ApiImageToTextPostRequest) Targets(targets []string) ApiImageToTextPostRequest {
	r.targets = &targets
	return r
}

// Originnal file format
func (r ApiImageToTextPostRequest) Format(format string) ApiImageToTextPostRequest {
	r.format = &format
	return r
}

// Link to file for translation
func (r ApiImageToTextPostRequest) Url(url string) ApiImageToTextPostRequest {
	r.url = &url
	return r
}

// Left to write angle to rotate scanned image / pdf
func (r ApiImageToTextPostRequest) Rotate(rotate int32) ApiImageToTextPostRequest {
	r.rotate = &rotate
	return r
}

// is handwritten text
func (r ApiImageToTextPostRequest) IsHandwritten(isHandwritten bool) ApiImageToTextPostRequest {
	r.isHandwritten = &isHandwritten
	return r
}

// for analysis only
func (r ApiImageToTextPostRequest) Origin(origin string) ApiImageToTextPostRequest {
	r.origin = &origin
	return r
}

// endpoints route
func (r ApiImageToTextPostRequest) Route(route string) ApiImageToTextPostRequest {
	r.route = &route
	return r
}

func (r ApiImageToTextPostRequest) File(file *os.File) ApiImageToTextPostRequest {
	r.file = file
	return r
}

func (r ApiImageToTextPostRequest) Execute() (*StatusResponse, *http.Response, error) {
	return r.ApiService.ImageToTextPostExecute(r)
}

/*
ImageToTextPost Translate text on image or scanned pdf

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiImageToTextPostRequest
*/
func (a *TransportApiService) ImageToTextPost(ctx context.Context) ApiImageToTextPostRequest {
	return ApiImageToTextPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return StatusResponse
func (a *TransportApiService) ImageToTextPostExecute(r ApiImageToTextPostRequest) (*StatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransportApiService.ImageToTextPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/image-to-text"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.source == nil {
		return localVarReturnValue, nil, reportError("source is required and must be specified")
	}
	if r.targets == nil {
		return localVarReturnValue, nil, reportError("targets is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Format", r.format, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "Source", r.source, "")
	{
		t := *r.targets
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "Targets", s.Index(i), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "Targets", t, "multi")
		}
	}
	if r.url != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Url", r.url, "")
	}
	if r.rotate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Rotate", r.rotate, "")
	}
	if r.isHandwritten != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "IsHandwritten", r.isHandwritten, "")
	}
	if r.origin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Origin", r.origin, "")
	}
	if r.route != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Route", r.route, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileLocalVarFormFileName string
	var fileLocalVarFileName string
	var fileLocalVarFileBytes []byte

	fileLocalVarFormFileName = "file"

	fileLocalVarFile := r.file

	if fileLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileLocalVarFile)

		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLanguagesGetRequest struct {
	ctx        context.Context
	ApiService *TransportApiService
}

func (r ApiLanguagesGetRequest) Execute() ([]LanguagePairData, *http.Response, error) {
	return r.ApiService.LanguagesGetExecute(r)
}

/*
LanguagesGet Return list of available language pairs

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiLanguagesGetRequest
*/
func (a *TransportApiService) LanguagesGet(ctx context.Context) ApiLanguagesGetRequest {
	return ApiLanguagesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []LanguagePairData
func (a *TransportApiService) LanguagesGetExecute(r ApiLanguagesGetRequest) ([]LanguagePairData, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []LanguagePairData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransportApiService.LanguagesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/languages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarkdownPostRequest struct {
	ctx              context.Context
	ApiService       *TransportApiService
	sourceLanguage   *string
	targetLanguages  *[]string
	outputFormat     *string
	file             *string
	originalFileName *string
	url              *string
	origin           *string
	savingMode       *string
	frontMatterList  *[][]string
}

// Language of original file
func (r ApiMarkdownPostRequest) SourceLanguage(sourceLanguage string) ApiMarkdownPostRequest {
	r.sourceLanguage = &sourceLanguage
	return r
}

// List of target languages
func (r ApiMarkdownPostRequest) TargetLanguages(targetLanguages []string) ApiMarkdownPostRequest {
	r.targetLanguages = &targetLanguages
	return r
}

// output file format
func (r ApiMarkdownPostRequest) OutputFormat(outputFormat string) ApiMarkdownPostRequest {
	r.outputFormat = &outputFormat
	return r
}

// File as byte array
func (r ApiMarkdownPostRequest) File(file string) ApiMarkdownPostRequest {
	r.file = &file
	return r
}

// Type in the file name. If null will be as request ID.
func (r ApiMarkdownPostRequest) OriginalFileName(originalFileName string) ApiMarkdownPostRequest {
	r.originalFileName = &originalFileName
	return r
}

// Link to file for translation. Ignore, if \\\&quot;file\\\&quot; property not null
func (r ApiMarkdownPostRequest) Url(url string) ApiMarkdownPostRequest {
	r.url = &url
	return r
}

// Url or name of application using this SDK. Not required.
func (r ApiMarkdownPostRequest) Origin(origin string) ApiMarkdownPostRequest {
	r.origin = &origin
	return r
}

// Toggle file saving mode for storage.  Is Files by default.
func (r ApiMarkdownPostRequest) SavingMode(savingMode string) ApiMarkdownPostRequest {
	r.savingMode = &savingMode
	return r
}

// List of lists of frontmatter paths
func (r ApiMarkdownPostRequest) FrontMatterList(frontMatterList [][]string) ApiMarkdownPostRequest {
	r.frontMatterList = &frontMatterList
	return r
}

func (r ApiMarkdownPostRequest) Execute() (*StatusResponse, *http.Response, error) {
	return r.ApiService.MarkdownPostExecute(r)
}

/*
MarkdownPost Translate Markdown files

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiMarkdownPostRequest
*/
func (a *TransportApiService) MarkdownPost(ctx context.Context) ApiMarkdownPostRequest {
	return ApiMarkdownPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return StatusResponse
func (a *TransportApiService) MarkdownPostExecute(r ApiMarkdownPostRequest) (*StatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransportApiService.MarkdownPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/markdown"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sourceLanguage == nil {
		return localVarReturnValue, nil, reportError("sourceLanguage is required and must be specified")
	}
	if strlen(*r.sourceLanguage) < 1 {
		return localVarReturnValue, nil, reportError("sourceLanguage must have at least 1 elements")
	}
	if r.targetLanguages == nil {
		return localVarReturnValue, nil, reportError("targetLanguages is required and must be specified")
	}
	if r.outputFormat == nil {
		return localVarReturnValue, nil, reportError("outputFormat is required and must be specified")
	}
	if strlen(*r.outputFormat) < 1 {
		return localVarReturnValue, nil, reportError("outputFormat must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "sourceLanguage", r.sourceLanguage, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "targetLanguages", r.targetLanguages, "csv")
	if r.file != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "file", r.file, "")
	}
	if r.originalFileName != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "originalFileName", r.originalFileName, "")
	}
	if r.url != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "url", r.url, "")
	}
	if r.origin != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "origin", r.origin, "")
	}
	if r.savingMode != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "savingMode", r.savingMode, "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "outputFormat", r.outputFormat, "")
	if r.frontMatterList != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "frontMatterList", r.frontMatterList, "csv")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPdfPostRequest struct {
	ctx            context.Context
	ApiService     *TransportApiService
	pdfFileRequest *PdfFileRequest
}

// String in body of request, containing JSON with parameters for translation.
func (r ApiPdfPostRequest) PdfFileRequest(pdfFileRequest PdfFileRequest) ApiPdfPostRequest {
	r.pdfFileRequest = &pdfFileRequest
	return r
}

func (r ApiPdfPostRequest) Execute() (*StatusResponse, *http.Response, error) {
	return r.ApiService.PdfPostExecute(r)
}

/*
PdfPost Translate pdf files

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPdfPostRequest
*/
func (a *TransportApiService) PdfPost(ctx context.Context) ApiPdfPostRequest {
	return ApiPdfPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return StatusResponse
func (a *TransportApiService) PdfPostExecute(r ApiPdfPostRequest) (*StatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransportApiService.PdfPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pdf"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pdfFileRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPresentationPostRequest struct {
	ctx                     context.Context
	ApiService              *TransportApiService
	presentationFileRequest *PresentationFileRequest
}

// String in body of request, containing JSON with parameters for translation.
func (r ApiPresentationPostRequest) PresentationFileRequest(presentationFileRequest PresentationFileRequest) ApiPresentationPostRequest {
	r.presentationFileRequest = &presentationFileRequest
	return r
}

func (r ApiPresentationPostRequest) Execute() (*StatusResponse, *http.Response, error) {
	return r.ApiService.PresentationPostExecute(r)
}

/*
PresentationPost Translate Microsoft PowerPoint presentations, odp

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPresentationPostRequest
*/
func (a *TransportApiService) PresentationPost(ctx context.Context) ApiPresentationPostRequest {
	return ApiPresentationPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return StatusResponse
func (a *TransportApiService) PresentationPostExecute(r ApiPresentationPostRequest) (*StatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransportApiService.PresentationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/presentation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.presentationFileRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResxPostRequest struct {
	ctx             context.Context
	ApiService      *TransportApiService
	resxFileRequest *ResxFileRequest
}

// String in body of request, containing JSON with parameters for translation.
func (r ApiResxPostRequest) ResxFileRequest(resxFileRequest ResxFileRequest) ApiResxPostRequest {
	r.resxFileRequest = &resxFileRequest
	return r
}

func (r ApiResxPostRequest) Execute() (*StatusResponse, *http.Response, error) {
	return r.ApiService.ResxPostExecute(r)
}

/*
ResxPost Translate RESX files

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiResxPostRequest
*/
func (a *TransportApiService) ResxPost(ctx context.Context) ApiResxPostRequest {
	return ApiResxPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return StatusResponse
func (a *TransportApiService) ResxPostExecute(r ApiResxPostRequest) (*StatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransportApiService.ResxPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/resx"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.resxFileRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSpreadsheetsPostRequest struct {
	ctx                    context.Context
	ApiService             *TransportApiService
	spreadsheetFileRequest *SpreadsheetFileRequest
}

// String in body of request, containing JSON with parameters for translation.
func (r ApiSpreadsheetsPostRequest) SpreadsheetFileRequest(spreadsheetFileRequest SpreadsheetFileRequest) ApiSpreadsheetsPostRequest {
	r.spreadsheetFileRequest = &spreadsheetFileRequest
	return r
}

func (r ApiSpreadsheetsPostRequest) Execute() (*StatusResponse, *http.Response, error) {
	return r.ApiService.SpreadsheetsPostExecute(r)
}

/*
SpreadsheetsPost Translate Microsoft Excel workbooks, ods

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSpreadsheetsPostRequest
*/
func (a *TransportApiService) SpreadsheetsPost(ctx context.Context) ApiSpreadsheetsPostRequest {
	return ApiSpreadsheetsPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return StatusResponse
func (a *TransportApiService) SpreadsheetsPostExecute(r ApiSpreadsheetsPostRequest) (*StatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransportApiService.SpreadsheetsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/spreadsheets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.spreadsheetFileRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTextPostRequest struct {
	ctx         context.Context
	ApiService  *TransportApiService
	textRequest *TextRequest
}

// String in body of request, containing JSON with parameters for translation.
func (r ApiTextPostRequest) TextRequest(textRequest TextRequest) ApiTextPostRequest {
	r.textRequest = &textRequest
	return r
}

func (r ApiTextPostRequest) Execute() (*StatusResponse, *http.Response, error) {
	return r.ApiService.TextPostExecute(r)
}

/*
TextPost Translate text

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTextPostRequest
*/
func (a *TransportApiService) TextPost(ctx context.Context) ApiTextPostRequest {
	return ApiTextPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return StatusResponse
func (a *TransportApiService) TextPostExecute(r ApiTextPostRequest) (*StatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransportApiService.TextPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/text"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.textRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTextRequestIdGetRequest struct {
	ctx        context.Context
	ApiService *TransportApiService
	requestId  string
}

func (r ApiTextRequestIdGetRequest) Execute() (*CloudTextResponse, *http.Response, error) {
	return r.ApiService.TextRequestIdGetExecute(r)
}

/*
TextRequestIdGet Return text translation status.  Also return translated text if translation was successful

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param requestId GUID which got from /v3/translation/text response
	@return ApiTextRequestIdGetRequest
*/
func (a *TransportApiService) TextRequestIdGet(ctx context.Context, requestId string) ApiTextRequestIdGetRequest {
	return ApiTextRequestIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		requestId:  requestId,
	}
}

// Execute executes the request
//
//	@return CloudTextResponse
func (a *TransportApiService) TextRequestIdGetExecute(r ApiTextRequestIdGetRequest) (*CloudTextResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CloudTextResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransportApiService.TextRequestIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/text/{requestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"requestId"+"}", url.PathEscape(parameterValueToString(r.requestId, "requestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
